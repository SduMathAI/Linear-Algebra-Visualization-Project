<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>å‡ ä½•çº¿æ€§ä»£æ•°å®éªŒå®¤ (GeoLinAlg) </title>
    <title>å‡ ä½•çº¿æ€§ä»£æ•°å®éªŒå®¤ (GeoLinAlg) - SVDåˆ†è§£ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --text: #f8fafc;
            --accent: #38bdf8;
            --border: #334155;
            --danger: #ef4444;
            --success: #22c55e
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: "Segoe UI", system-ui, sans-serif;
            overflow: hidden;
            display: flex;
            height: 100vh
        }

        #chat-history,
        #chat-history * {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text
        }

        .msg-ai pre {
            background: #0f172a;
            padding: 5px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 5px 0 0 0;
            white-space: pre-wrap;
            word-wrap: break-word
        }

        .msg-ai p,
        .msg-user p {
            margin: 0
        }

        .msg-ai,
        .msg-user {
            cursor: text
        }

        #chat-input {
            flex: 1;
            background: #020617;
            border: 1px solid #475569;
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text
        }

        #chat-history {
            height: 200px;
            background: rgba(15, 23, 42, .9);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            color: var(--text);
            font-size: 12px;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            gap: 8px;
            cursor: default
        }

        #sidebar,
        #main .hint,
        .overlay-controls,
        .undo-redo-controls,
        .history-status,
        button,
        .section-title,
        .obj-item,
        .prop-row,
        .matrix-val,
        .ctx-item,
        #toolbar,
        #object-list,
        #properties-panel {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none
        }

        #sidebar {
            width: 320px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 20;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3)
        }

        #main {
            flex: 1;
            position: relative;
            cursor: crosshair
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%
        }

        .header {
            padding: 15px;
            background: #0b1120;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--accent)
        }

        .content {
            flex: 1;
            overflow-y: auto;
            padding: 10px
        }

        button {
            background: #334155;
            color: #fff;
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all .1s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            width: 100%
        }

        button:hover:not(:disabled) {
            background: #475569;
            border-color: #64748b
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed
        }

        button.primary {
            background: var(--accent);
            color: #0f172a;
            border-color: var(--accent);
            font-weight: 700
        }

        button.secondary {
            background: transparent;
            border: 1px dashed #64748b;
            color: #94a3b8
        }

        button.anim-btn {
            background: rgba(34, 197, 94, 0.2);
            border-color: var(--success);
            color: var(--success)
        }

        button.anim-btn:hover {
            background: rgba(34, 197, 94, 0.3)
        }

        .section {
            margin-bottom: 20px;
            border-bottom: 1px solid #334155;
            padding-bottom: 15px
        }

        .section-title {
            font-size: 11px;
            color: #94a3b8;
            text-transform: uppercase;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: .5px
        }

        .tool-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px
        }

        #object-list {
            max-height: 250px;
            overflow-y: auto
        }

        .obj-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: #0f172a;
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: all .1s;
            font-size: 12px
        }

        .obj-item:hover {
            border-color: #64748b
        }

        .obj-item.selected {
            border-left-color: var(--accent);
            background: #1e293b;
            border-color: #475569
        }

        .prop-group {
            background: #0f172a;
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            border: 1px solid #334155
        }

        .prop-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 12px
        }

        .prop-row:last-child {
            margin-bottom: 0
        }

        .prop-row label {
            color: #cbd5e1;
            min-width: 40px;
            font-weight: 500
        }

        input[type=number],
        input[type=text] {
            background: #020617;
            border: 1px solid #475569;
            color: #fff;
            padding: 4px 6px;
            border-radius: 3px;
            flex: 1;
            font-family: monospace;
            font-size: 11px
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            margin: 4px 0
        }

        .matrix-val {
            text-align: center;
            background: #1e293b;
            padding: 4px;
            border-radius: 3px;
            color: var(--accent);
            font-family: monospace;
            font-size: 11px
        }

        #context-menu {
            position: absolute;
            display: none;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 4px;
            min-width: 120px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, .5);
            z-index: 1000
        }

        .ctx-item {
            padding: 6px 10px;
            font-size: 12px;
            color: #f1f5f9;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px
        }

        .ctx-item:hover {
            background: #334155
        }

        .ctx-item.delete {
            color: #ef4444
        }

        .ctx-divider {
            height: 1px;
            background: #334155;
            margin: 4px 0
        }

        .overlay-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, .95);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            gap: 16px;
            align-items: center;
            backdrop-filter: blur(8px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, .5);
            pointer-events: auto;
            max-width: 90vw;
            overflow-x: auto
        }

        .hint {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 13px;
            color: rgba(255, 255, 255, .7);
            pointer-events: none;
            text-shadow: 0 1px 3px #000;
            background: rgba(0, 0, 0, .5);
            padding: 4px 8px;
            border-radius: 4px
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100px;
            background: transparent
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            margin-top: -6px
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px
        }

        .val-display {
            font-family: monospace;
            color: var(--accent);
            font-size: 14px;
            width: 40px;
            text-align: center
        }

        /* èŠå¤©çª—å£å®¹å™¨ - æ ¸å¿ƒï¼šå¼ºåˆ¶åå­—å…‰æ ‡ç©¿é€æ‰€æœ‰å­å…ƒç´ ç”Ÿæ•ˆï¼Œä¼˜å…ˆçº§æ‹‰æ»¡ */
        #chat-container {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            z-index: 1000;
            user-select: none;
            -webkit-user-drag: none;
            box-sizing: border-box;
            /* âœ… æ ¸å¿ƒ1ï¼šå¼ºåˆ¶ç”Ÿæ•ˆ åŸç”Ÿåå­—ç§»åŠ¨å…‰æ ‡ï¼ˆä½ è¦çš„åå­—é”®å½¢æ€ï¼‰+ ä¼˜å…ˆçº§é”æ­» */
            cursor: move !important;
        }
        /* âœ… é¼ æ ‡æŒ‰ä½æ‹–åŠ¨æ—¶ï¼Œä¿æŒåå­—å…‰æ ‡ä¸å˜ */
        #chat-container:active {
            cursor: move !important;
        }
        /* âœ… å…³é”®ä¿®å¤ï¼šèŠå¤©å†…å®¹åŒº - æ‚¬æµ®æ—¶æ˜¾ç¤ºæ–‡æœ¬å…‰æ ‡ï¼ˆå¯é€‰ä¸­æ–‡å­—ï¼‰ï¼ŒæŒ‰ä½é¼ æ ‡ç¬é—´å¼ºåˆ¶å˜å›åå­—å…‰æ ‡ï¼ˆå¯æ‹–åŠ¨ï¼‰ */
        #chat-history {
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }
        #chat-history:active {
            cursor: move !important;
        }
        /* âœ… è¾“å…¥æ¡†/å‘é€æŒ‰é’®/è¾“å…¥åŒº - æ­£å¸¸é»˜è®¤å…‰æ ‡ï¼Œä¸å½±å“ä½¿ç”¨ */
        #chat-input, #btn-send, #chat-input-area {
            cursor: default;
            pointer-events: auto;
        }

        #chat-history {
            height: 200px;
            background: rgba(15, 23, 42, .9);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            color: var(--text);
            font-size: 12px;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .msg-user {
            align-self: flex-end;
            background: var(--accent);
            color: #0f172a;
            padding: 6px 10px;
            border-radius: 8px 8px 0 8px;
            max-width: 80%;
            word-wrap: break-word
        }

        .msg-ai {
            align-self: flex-start;
            background: #334155;
            color: #f1f5f9;
            padding: 6px 10px;
            border-radius: 8px 8px 8px 0;
            max-width: 90%;
            word-wrap: break-word
        }

        .msg-ai pre {
            background: #0f172a;
            padding: 5px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 5px 0 0 0
        }

        #chat-input-area {
            background: rgba(15, 23, 42, .95);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            display: flex;
            gap: 8px;
            pointer-events: auto
        }

        #chat-input {
            flex: 1;
            background: #020617;
            border: 1px solid #475569;
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            font-size: 12px;
            outline: none
        }

        #chat-input:focus {
            border-color: var(--accent)
        }

        #btn-send {
            width: auto;
            padding: 0 12px;
            background: var(--accent);
            color: #0f172a;
            font-weight: bold
        }

        .typing {
            align-self: flex-start;
            display: flex;
            gap: 4px;
            background: #334155;
            color: #f1f5f9;
            padding: 6px 10px;
            border-radius: 8px 8px 8px 0;
            max-width: 90%;
            word-wrap: break-word
        }

        .typing .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            animation: dotPulse 1s infinite ease-in-out
        }

        .typing .dot:nth-child(2) {
            animation-delay: .15s
        }

        .typing .dot:nth-child(3) {
            animation-delay: .3s
        }

        @keyframes dotPulse {

            0%,
            80%,
            100% {
                transform: scale(0);
                opacity: .5
            }

            40% {
                transform: scale(1);
                opacity: 1
            }
        }

        .undo-redo-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 1000
        }

        .undo-redo-controls button {
            width: auto;
            padding: 6px 12px;
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(8px);
            border: 1px solid var(--border)
        }

        .undo-redo-controls button:hover {
            background: rgba(51, 65, 85, 0.9)
        }

        .undo-redo-controls button:disabled {
            opacity: 0.4
        }

        .undo-redo-controls button.undo:not(:disabled)::before {
            content: "â†¶ "
        }

        .undo-redo-controls button.redo:not(:disabled)::before {
            content: "â†· "
        }

        .history-status {
            font-size: 11px;
            color: #64748b;
            position: absolute;
            top: 50px;
            right: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 3px 8px;
            border-radius: 4px;
            pointer-events: none
        }

        .math-matrix {
            display: inline-grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 12px;
            padding: 6px 10px;
            position: relative;
            margin: 0 6px;
            font-family: "Consolas", monospace;
            font-size: 13px;
            color: #e2e8f0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            vertical-align: middle
        }

        .math-matrix div {
            text-align: right
        }

        .math-matrix::before,
        .math-matrix::after {
            content: "";
            position: absolute;
            top: -2px;
            bottom: -2px;
            width: 8px;
            border: 2px solid #94a3b8
        }

        .math-matrix::before {
            left: -2px;
            border-right: none;
            border-radius: 6px 0 0 6px
        }

        .math-matrix::after {
            right: -2px;
            border-left: none;
            border-radius: 0 6px 6px 0
        }

        .matrix-desc {
            font-size: 10px;
            color: #94a3b8;
            margin-top: 4px;
            text-align: center;
            line-height: 1.3
        }

        .matrix-desc em {
            color: #fb923c;
            font-style: normal;
            font-weight: bold
        }
    </style>
</head>

<body>
    <div id="context-menu">
        <div class="ctx-item delete" onclick="actions.deleteSelected()">ğŸ—‘ï¸ åˆ é™¤å¯¹è±¡</div>
        <div class="ctx-divider"></div>
        <div class="ctx-item" onclick="app.resetView()">ğŸ‘ï¸ é‡ç½®è§†å›¾</div>
        <div class="ctx-item" onclick="app.reset()">ğŸ§¹ æ¸…ç©ºç”»å¸ƒ</div>
        <div class="ctx-divider"></div>
        <div class="ctx-item" onclick="historyManager.undo()">â†¶ æ’¤é”€ (Ctrl+Z)</div>
        <div class="ctx-item" onclick="historyManager.redo()">â†· é‡åš (Ctrl+Y)</div>
    </div>
    <div id="sidebar">
        <div class="header"><span>ğŸ”¢ GeoLinAlg</span><button onclick="historyManager.undo()" class="secondary" style="width:auto;padding:4px 8px;font-size:10px;" title="æ’¤é”€ (Ctrl+Z)" id="btn-undo">â†¶</button><button onclick="historyManager.redo()" class="secondary" style="width:auto;padding:4px 8px;font-size:10px;" title="é‡åš (Ctrl+Y)" id="btn-redo">â†·</button><button onclick="app.reset()" class="secondary" style="width:auto;padding:4px 8px;font-size:10px;">æ¸…ç©º</button></div>
        <div class="content">
            <div class="section">
                <div class="section-title">å·¥å…·ç®± (é€‰ä¸­å¯¹è±¡ä»¥æ¿€æ´»)</div>
                <div class="tool-grid"><button id="btn-create-vec" onclick="actions.createVector()" disabled>âœ åˆ›å»ºå‘é‡ (é€‰2ç‚¹)</button><button id="btn-create-mat" onclick="actions.createMatrix()" disabled>â–¦ åˆ›å»ºçŸ©é˜µ (é€‰2å‘é‡)</button><button id="btn-lin-comb" onclick="actions.createLinComb()" disabled>âˆ‘ çº¿æ€§ç»„åˆ (é€‰2+å‘é‡)</button><button id="btn-create-eigen" onclick="actions.createEigen()" disabled>Î» æ˜¾ç¤ºç‰¹å¾ç³» (é€‰1çŸ©é˜µ)</button><button id="btn-apply-trans" onclick="actions.applyTransform()" disabled>âš¡ åº”ç”¨å˜æ¢ (é€‰1çŸ©é˜µ+1å‘é‡/çŸ©é˜µ)</button></div>
                <div style="margin-top:10px;font-size:11px;color:#64748b;line-height:1.4;"><b>æ“ä½œæŒ‡å—:</b><br>â€¢ å·¦é”®ç©ºç™½: åˆ›å»ºç‚¹ï¼ˆé è¿‘æ•´æ•°æ—¶è‡ªåŠ¨å¸é™„ï¼ŒAlt å–æ¶ˆå¸é™„ï¼‰<br>â€¢ å·¦é”®å¯¹è±¡: é€‰æ‹© (æŒ‰ä½Ctrlå¤šé€‰)<br>â€¢ æ‹–åŠ¨ç‚¹: ç§»åŠ¨ï¼ˆé è¿‘æ•´æ•°æ—¶è‡ªåŠ¨å¸é™„ï¼ŒAlt å–æ¶ˆå¸é™„ï¼‰<br>â€¢ ä¸­é”®æ‹–åŠ¨: å¹³ç§»ç”»å¸ƒ<br>â€¢ å³é”®å¯¹è±¡: å¼¹å‡ºèœå•â€¢ Ctrl+Z: æ’¤é”€ | Ctrl+Y: é‡åš</div>
            </div>
            <div class="section">
                <div class="section-title">å±æ€§</div>
                <div id="properties-panel"></div>
            </div>
            <div class="section" style="border:none;">
                <div class="section-title">å¯¹è±¡åˆ—è¡¨</div>
                <div id="object-list"></div>
            </div>
        </div>
    </div>
    <div id="main">
        <div class="hint">å·¦é”®: åˆ›å»º/é€‰æ‹©/æ‹–åŠ¨ | ä¸­é”®: å¹³ç§» | å³é”®: èœå• | é è¿‘æ•´æ•°è‡ªåŠ¨å¸é™„ (é˜ˆå€¼ 0.25) | Alt å–æ¶ˆå¸é™„ | Ctrl+Z: æ’¤é”€ | Ctrl+Y: é‡åš</div>
        <canvas id="canvas"></canvas>
        <div class="overlay-controls" id="comb-controls" style="display:none;"></div>
        <div class="overlay-controls" id="trans-controls" style="display:none;"></div>
        <div class="undo-redo-controls"><button id="undo-btn" class="undo" onclick="historyManager.undo()" disabled>æ’¤é”€</button><button id="redo-btn" class="redo" onclick="historyManager.redo()" disabled>é‡åš</button></div>
        <div class="history-status" id="history-status">å†å²: 0/0</div>
        <div id="chat-container">
            <div id="chat-history">
                <div class="msg-ai">ä½ å¥½ï¼æˆ‘æ˜¯ä½ çš„çº¿æ€§ä»£æ•°å¯è§†åŒ–åŠ©æ•™ã€‚æˆ‘å¯ä»¥ä¸ºä½ åŠ¨æ€æ¼”ç¤ºçŸ©é˜µå˜æ¢ã€å‘é‡åˆæˆåŠç‰¹å¾å€¼ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚æƒ³çœ‹çœ‹å…·ä½“çš„çŸ©é˜µæ˜¯å¦‚ä½•â€˜æ‹‰ä¼¸â€™ç©ºé—´çš„å—ï¼Ÿå¿«æ¥å‘Šè¯‰æˆ‘ä½ çš„æƒ³æ³•ï¼Œæˆ–è€…ç›´æ¥æ‹–åŠ¨å›¾è¡¨å¼€å§‹æ¢ç´¢å§ï¼</div>
            </div>
            <div id="chat-input-area"><input type="text" id="chat-input" placeholder="è¾“å…¥æŒ‡ä»¤ (ä¾‹å¦‚: å±•ç¤ºæ—‹è½¬çŸ©é˜µ)..." onkeydown="if(event.key==='Enter') sendChat()"><button id="btn-send" onclick="sendChat()">å‘é€</button></div>
        </div>
    </div>
    <script>
        const SNAP_STEP = 1;
        const SNAP_THRESH = 0.25;
        const snapIfNear = v => {
            const n = Math.round(v / SNAP_STEP) * SNAP_STEP;
            return Math.abs(v - n) <= SNAP_THRESH ? n : v
        };
        const MathLib = {
            add: (a, b) => ({
                x: a.x + b.x,
                y: a.y + b.y
            }),
            sub: (a, b) => ({
                x: a.x - b.x,
                y: a.y - b.y
            }),
            scale: (v, s) => ({
                x: v.x * s,
                y: v.y * s
            }),
            len: v => Math.hypot(v.x, v.y),
            det: (v1, v2) => v1.x * v2.y - v1.y * v2.x,
            transform: (v, c1, c2) => ({
                x: c1.x * v.x + c2.x * v.y,
                y: c1.y * v.x + c2.y * v.y
            }),
            matMul: (m1, m2) => ({
                c1: MathLib.transform(m2.c1, m1.c1, m1.c2),
                c2: MathLib.transform(m2.c2, m1.c1, m1.c2)
            }),
            lerp: (v1, v2, t) => ({
                x: v1.x + (v2.x - v1.x) * t,
                y: v1.y + (v2.y - v1.y) * t
            }),
            matInv: (c1, c2) => {
                const d = c1.x * c2.y - c1.y * c2.x;
                return Math.abs(d) < 1e-9 ? {
                    c1: {
                        x: 1,
                        y: 0
                    },
                    c2: {
                        x: 0,
                        y: 1
                    }
                } : {
                    c1: {
                        x: c2.y / d,
                        y: -c1.y / d
                    },
                    c2: {
                        x: -c2.x / d,
                        y: c1.x / d
                    }
                }
            },
            matTrans: (c1, c2) => ({
                c1: {
                    x: c1.x,
                    y: c2.x
                },
                c2: {
                    x: c1.y,
                    y: c2.y
                }
            }),
            polarQ: (c1, c2) => {
                let Q = {
                    c1: {
                        ...c1
                    },
                    c2: {
                        ...c2
                    }
                };
                for (let i = 0; i < 5; i++) {
                    const I = MathLib.matInv(Q.c1, Q.c2),
                        T = MathLib.matTrans(I.c1, I.c2);
                    Q.c1.x = (Q.c1.x + T.c1.x) * .5;
                    Q.c1.y = (Q.c1.y + T.c1.y) * .5;
                    Q.c2.x = (Q.c2.x + T.c2.x) * .5;
                    Q.c2.y = (Q.c2.y + T.c2.y) * .5
                }
                return Q
            },
            rotateVec: (v, a) => {
                const c = Math.cos(a),
                    s = Math.sin(a);
                return {
                    x: v.x * c - v.y * s,
                    y: v.x * s + v.y * c
                }
            },
            solveEigen: (c1, c2) => {
                const a = c1.x,
                    b = c2.x,
                    c = c1.y,
                    d = c2.y,
                    tr = a + d,
                    det = a * d - b * c,
                    delta = tr * tr - 4 * det;
                if (delta < -1e-9) return [];
                const l1 = (tr + Math.sqrt(Math.max(0, delta))) / 2,
                    l2 = (tr - Math.sqrt(Math.max(0, delta))) / 2;
                const getEv = l => {
                    if (Math.abs(b) > 1e-5) return {
                        x: b,
                        y: l - a
                    };
                    if (Math.abs(c) > 1e-5) return {
                        x: l - d,
                        y: c
                    };
                    if (Math.abs(a - l) > 1e-5) return {
                        x: 0,
                        y: 1
                    };
                    return {
                        x: 1,
                        y: 0
                    }
                };
                const norm = v => {
                    const l = Math.hypot(v.x, v.y);
                    return l < 1e-9 ? {
                        x: 0,
                        y: 0
                    } : {
                        x: v.x / l,
                        y: v.y / l
                    }
                };
                const res = [{
                    val: l1,
                    vec: norm(getEv(l1))
                }];
                if (Math.abs(delta) > 1e-5) res.push({
                    val: l2,
                    vec: norm(getEv(l2))
                });
                return res
            },
            svd: (c1, c2) => {
                const a = c1.x,
                    b = c2.x,
                    c = c1.y,
                    d = c2.y;
                const E = a * a + c * c,
                    F = a * b + c * d,
                    H = b * b + d * d;
                const tr = E + H,
                    det = E * H - F * F,
                    gap = Math.sqrt(Math.max(0, tr * tr - 4 * det));
                const l1 = (tr + gap) / 2,
                    l2 = (tr - gap) / 2;
                const s1 = Math.sqrt(l1),
                    s2 = Math.sqrt(l2);
                let v1 = {
                    x: F,
                    y: l1 - E
                };
                let mag = Math.hypot(v1.x, v1.y);
                if (mag < 1e-9) v1 = {
                    x: 1,
                    y: 0
                };
                else v1 = {
                    x: v1.x / mag,
                    y: v1.y / mag
                };
                let v2 = {
                    x: -v1.y,
                    y: v1.x
                };
                let u1 = {
                    x: s1 > 1e-9 ? (a * v1.x + b * v1.y) / s1 : 1,
                    y: s1 > 1e-9 ? (c * v1.x + d * v1.y) / s1 : 0
                };
                let u2 = {
                    x: s2 > 1e-9 ? (a * v2.x + b * v2.y) / s2 : -u1.y,
                    y: s2 > 1e-9 ? (c * v2.x + d * v2.y) / s2 : u1.x
                };
                if (u1.x * u2.y - u1.y * u2.x < 0) {
                    u2.x = -u2.x;
                    u2.y = -u2.y;
                    var S2_final = -s2
                } else {
                    var S2_final = s2
                }
                return {
                    U: {
                        c1: u1,
                        c2: u2
                    },
                    S: {
                        c1: {
                            x: s1,
                            y: 0
                        },
                        c2: {
                            x: 0,
                            y: S2_final
                        }
                    },
                    V: {
                        c1: v1,
                        c2: v2
                    }
                }
            }
        };
        const AnimationEngine = {
            animations: [],
            add(anim) {
                this.animations.push({
                    ...anim,
                    startTime: Date.now()
                });
                if (!this.running) this.loop()
            },
            running: false,
            loop() {
                if (this.animations.length === 0) {
                    this.running = false;
                    return
                }
                this.running = true;
                const now = Date.now();
                this.animations = this.animations.filter(anim => {
                    const elapsed = now - anim.startTime;
                    let t = Math.min(1, elapsed / anim.duration);
                    t = t * (2 - t);
                    anim.onUpdate(t);
                    if (t >= 1 && anim.onComplete) anim.onComplete();
                    return t < 1
                });
                app.render();
                requestAnimationFrame(() => this.loop())
            }
        };
        const historyManager = {
            history: [],
            currentIndex: -1,
            maxHistory: 50,
            recording: true,
            lastSaveTime: 0,
            serializeState() {
                return {
                    objects: app.objects.map(obj => this.serializeObject(obj)),
                    selection: app.selection.map(obj => obj.id),
                    OBJ_ID: OBJ_ID,
                    timestamp: Date.now()
                }
            },
            serializeObject(obj) {
                const base = {
                    id: obj.id,
                    type: obj.type,
                    label: obj.label,
                    selected: obj.selected,
                    color: obj.color
                };
                switch (obj.type) {
                    case 'point':
                        return {
                            ...base, pos: {
                                ...obj.pos
                            }
                        };
                    case 'vector':
                        return {
                            ...base, origin: {
                                ...obj.origin
                            }, vec: {
                                ...obj.vec
                            }, len: obj.len, deps: obj.deps ? obj.deps.map(dep => dep.id) : []
                        };
                    case 'matrix':
                        return {
                            ...base, c1: {
                                ...obj.c1
                            }, c2: {
                                ...obj.c2
                            }, origin: {
                                ...obj.origin
                            }, det: obj.det, area: obj.area, deps: obj.deps ? obj.deps.map(dep => dep.id) : []
                        };
                    case 'eigen':
                        return {
                            ...base, origin: {
                                ...obj.origin
                            }, eigen: obj.eigen.map(e => ({
                                val: e.val,
                                vec: {
                                    ...e.vec
                                }
                            })), deps: obj.deps ? obj.deps.map(dep => dep.id) : []
                        };
                    case 'trans_vec':
                        return {
                            ...base, origin: {
                                ...obj.origin
                            }, vec: {
                                ...obj.vec
                            }, originalLen: obj.originalLen, len: obj.len, scaleRatio: obj.scaleRatio, deps: obj.deps ? obj.deps.map(dep => dep.id) : []
                        };
                    case 'trans_mat':
                        return {
                            ...base, origin: {
                                ...obj.origin
                            }, c1: {
                                ...obj.c1
                            }, c2: {
                                ...obj.c2
                            }, originalArea: obj.originalArea, area: obj.area, scaleRatio: obj.scaleRatio, deps: obj.deps ? obj.deps.map(dep => dep.id) : []
                        };
                    case 'lin_comb':
                        return {
                            ...base, origin: obj.origin ? {
                                ...obj.origin
                            } : {
                                x: 0,
                                y: 0
                            }, vec: obj.vec ? {
                                ...obj.vec
                            } : {
                                x: 0,
                                y: 0
                            }, coeffs: [...obj.coeffs], deps: obj.deps ? obj.deps.map(dep => dep.id) : []
                        };
                    default:
                        return base
                }
            },
            restoreState(state) {
                this.recording = false;
                OBJ_ID = state.OBJ_ID;
                app.objects = [];
                app.selection = [];
                const idMap = new Map();
                state.objects.forEach(objData => {
                    let obj;
                    switch (objData.type) {
                        case 'point':
                            obj = new Point(objData.pos.x, objData.pos.y);
                            break;
                        case 'vector':
                            obj = new Vector(null, null);
                            obj.origin = objData.origin;
                            obj.vec = objData.vec;
                            obj.len = objData.len;
                            break;
                        case 'matrix':
                            obj = new Matrix(null, null);
                            obj.c1 = objData.c1;
                            obj.c2 = objData.c2;
                            obj.origin = objData.origin;
                            obj.det = objData.det;
                            obj.area = objData.area;
                            break;
                        case 'eigen':
                            obj = new EigenSystem(null);
                            obj.origin = objData.origin;
                            obj.eigen = objData.eigen;
                            break;
                        case 'trans_vec':
                            obj = new TransformedVector(null, null);
                            obj.origin = objData.origin;
                            obj.vec = objData.vec;
                            obj.originalLen = objData.originalLen;
                            obj.len = objData.len;
                            obj.scaleRatio = objData.scaleRatio;
                            break;
                        case 'trans_mat':
                            obj = new TransformedMatrix(null, null);
                            obj.origin = objData.origin;
                            obj.c1 = objData.c1;
                            obj.c2 = objData.c2;
                            obj.originalArea = objData.originalArea;
                            obj.area = objData.area;
                            obj.scaleRatio = objData.scaleRatio;
                            break;
                        case 'lin_comb':
                            obj = new LinearComb([]);
                            obj.origin = objData.origin;
                            obj.vec = objData.vec;
                            obj.coeffs = objData.coeffs;
                            break;
                        default:
                            obj = new SceneObject(objData.type)
                    }
                    obj.id = objData.id;
                    obj.label = objData.label;
                    obj.selected = objData.selected;
                    if (objData.color) obj.color = objData.color;
                    idMap.set(objData.id, obj);
                    app.objects.push(obj)
                });
                state.objects.forEach((objData, index) => {
                    const obj = app.objects[index];
                    if (objData.deps && objData.deps.length > 0) obj.deps = objData.deps.map(depId => idMap.get(depId)).filter(Boolean)
                });
                app.selection = state.selection.map(id => idMap.get(id)).filter(obj => obj);
                app.objects.forEach(obj => {
                    if (obj.update) obj.update();
                    obj.selected = app.selection.includes(obj)
                });
                app.updateUI();
                app.render();
                this.recording = true
            },
            saveState() {
                if (!this.recording) return;
                const now = Date.now();
                if (now - this.lastSaveTime < 100) return;
                this.lastSaveTime = now;
                const state = this.serializeState();
                this.history = this.history.slice(0, this.currentIndex + 1);
                this.history.push(state);
                if (this.history.length > this.maxHistory) this.history.shift();
                this.currentIndex = this.history.length - 1;
                this.updateUI()
            },
            beginBatch() {
                this.recording = false
            },
            endBatch() {
                this.recording = true;
                this.saveState()
            },
            undo() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.restoreState(this.history[this.currentIndex]);
                    return true
                }
                return false
            },
            redo() {
                if (this.currentIndex < this.history.length - 1) {
                    this.currentIndex++;
                    this.restoreState(this.history[this.currentIndex]);
                    return true
                }
                return false
            },
            updateUI() {
                const undoBtn = document.getElementById('undo-btn');
                const redoBtn = document.getElementById('redo-btn');
                const historyStatus = document.getElementById('history-status');
                if (undoBtn) undoBtn.disabled = this.currentIndex <= 0;
                if (redoBtn) redoBtn.disabled = this.currentIndex >= this.history.length - 1;
                if (historyStatus) {
                    historyStatus.textContent = `å†å²: ${this.currentIndex+1}/${this.history.length}`
                }
            },
            clear() {
                this.history = [];
                this.currentIndex = -1;
                this.updateUI()
            },
            createDemoObjects() {
                this.recording = false;
                const p1 = new Point(0, 0);
                const p2 = new Point(3, 0);
                const p3 = new Point(1, 2);
                app.objects.push(p1, p2, p3);
                const v1 = new Vector(p1, p2);
                const v2 = new Vector(p1, p3);
                app.objects.push(v1, v2);
                const matrix = new Matrix(v1, v2);
                app.objects.push(matrix);
                app.objects.forEach(obj => {
                    if (obj.update) obj.update()
                });
                this.recording = true;
                app.updateUI();
                app.render()
            },
            init() {
                this.recording = false;
                app.objects = [];
                app.selection = [];
                OBJ_ID = 1;
                this.createDemoObjects();
                this.saveState();
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z' || e.key === 'Z') {
                            e.preventDefault();
                            this.undo()
                        } else if (e.key === 'y' || e.key === 'Y') {
                            e.preventDefault();
                            this.redo()
                        }
                    }
                })
            }
        };
        let OBJ_ID = 1;
        const genId = () => `obj_${OBJ_ID++}`;
        class SceneObject {
            constructor(t) {
                this.id = genId();
                this.type = t;
                this.selected = false;
                this.deps = [];
                this.label = ""
            }
            update() {}
            render() {}
            hitTest(s, w, v) {
                return false
            }
            getZIndex() {
                return 0
            }
        }
        class Point extends SceneObject {
            constructor(x, y) {
                super("point");
                this.pos = {
                    x,
                    y
                };
                this.label = `P${OBJ_ID-1}`
            }
            getZIndex() {
                return 10
            }
            render(ctx, view) {
                const s = view.toScreen(this.pos);
                ctx.beginPath();
                ctx.arc(s.x, s.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = this.selected ? "#eab308" : "#38bdf8";
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = "#94a3b8";
                ctx.font = "10px monospace";
                ctx.fillText(this.label, s.x + 8, s.y - 8)
            }
            hitTest(s, w, v) {
                const p = v.toScreen(this.pos);
                return (s.x - p.x) ** 2 + (s.y - p.y) ** 2 < 100
            }
        }
        class Vector extends SceneObject {
            constructor(pStart, pEnd) {
                super("vector");
                if (pStart && pEnd) {
                    this.deps = [pStart, pEnd]
                } else {
                    this.deps = []
                }
                this.label = `v${OBJ_ID-1}`;
                let h = Math.random() * 330;
                if (h > 30) h += 30;
                this.color = `hsl(${h},70%,60%)`;
                this.update()
            }
            getZIndex() {
                return 5
            }
            update() {
                if (!this.deps[0] || !this.deps[1]) return;
                this.origin = this.deps[0].pos;
                this.vec = MathLib.sub(this.deps[1].pos, this.origin);
                this.len = MathLib.len(this.vec)
            }
            render(ctx, view) {
                const start = view.toScreen(this.origin),
                    end = view.toScreen(MathLib.add(this.origin, this.vec));
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.strokeStyle = this.selected ? "#eab308" : this.color;
                ctx.lineWidth = 3;
                ctx.stroke();
                drawArrowHead(ctx, start, end, ctx.strokeStyle);
                const mid = {
                    x: (start.x + end.x) / 2,
                    y: (start.y + end.y) / 2
                };
                ctx.fillStyle = this.color;
                ctx.font = "bold 12px sans-serif";
                ctx.fillText(`${this.label} (${this.len.toFixed(1)})`, mid.x + 5, mid.y - 5)
            }
            hitTest(s, w, v) {
                const p1 = v.toScreen(this.origin),
                    p2 = v.toScreen(MathLib.add(this.origin, this.vec));
                const l2 = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
                if (l2 === 0) return (s.x - p1.x) ** 2 + (s.y - p1.y) ** 2 < 64;
                let t = ((s.x - p1.x) * (p2.x - p1.x) + (s.y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const proj = {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
                return (s.x - proj.x) ** 2 + (s.y - proj.y) ** 2 < 64
            }
        }
        class Matrix extends SceneObject {
            constructor(v1, v2) {
                super("matrix");
                if (v1 && v2) {
                    this.deps = [v1, v2]
                } else {
                    this.deps = []
                }
                this.label = `M${OBJ_ID-1}`;
                this.color = "#7c3aed";
                this.update()
            }
            getZIndex() {
                return 1
            }
            update() {
                if (!this.deps[0] || !this.deps[1]) return;
                this.c1 = this.deps[0].vec;
                this.c2 = this.deps[1].vec;
                this.origin = this.deps[0].origin;
                this.det = MathLib.det(this.c1, this.c2);
                this.area = Math.abs(this.det);
                this.eigen = MathLib.solveEigen(this.c1, this.c2)
            }
            render(ctx, view) {
                const o = view.toScreen(this.origin),
                    p1 = view.toScreen(MathLib.add(this.origin, this.c1)),
                    p2 = view.toScreen(MathLib.add(this.origin, this.c2)),
                    pSum = view.toScreen(MathLib.add(this.origin, MathLib.add(this.c1, this.c2)));
                const c = this.selected ? "#eab308" : (this.color || "#7c3aed");
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(o.x, o.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.lineTo(pSum.x, pSum.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.closePath();
                ctx.fillStyle = c;
                ctx.globalAlpha = this.selected ? 0.3 : 0.2;
                ctx.fill();
                ctx.strokeStyle = c;
                ctx.lineWidth = 1;
                ctx.globalAlpha = this.selected ? 1 : 0.5;
                ctx.stroke();
                ctx.restore();
                ctx.fillStyle = "#ddd6fe";
                ctx.font = "11px sans-serif";
                ctx.fillText(`Area: ${this.area.toFixed(1)}`, pSum.x + 5, pSum.y)
            }
            hitTest(s, w, v) {
                const dx = w.x - this.origin.x,
                    dy = w.y - this.origin.y,
                    det = this.c1.x * this.c2.y - this.c1.y * this.c2.x;
                if (Math.abs(det) < 1e-9) return false;
                const u = (dx * this.c2.y - dy * this.c2.x) / det,
                    v_ = (this.c1.x * dy - this.c1.y * dx) / det;
                return u >= 0 && u <= 1 && v_ >= 0 && v_ <= 1
            }
        }
        class EigenSystem extends SceneObject {
            constructor(matrix) {
                super("eigen");
                if (matrix) {
                    this.deps = [matrix]
                } else {
                    this.deps = []
                }
                this.label = `Eig(${matrix?matrix.label:'?'})`;
                this.animState = {
                    t: 1
                };
                this.update();
                this.triggerAnimation()
            }
            getZIndex() {
                return 2
            }
            triggerAnimation() {
                this.animState.t = 0;
                AnimationEngine.add({
                    duration: 1200,
                    onUpdate: t => {
                        this.animState.t = t
                    },
                    onComplete: () => {
                        this.animState.t = 1
                    }
                })
            }
            update() {
                if (!this.deps[0]) return;
                const mat = this.deps[0];
                this.origin = mat.origin;
                this.eigen = MathLib.solveEigen(mat.c1, mat.c2)
            }
            render(ctx, view) {
                const o = view.toScreen(this.origin);
                const t = this.animState.t;
                const stdX = {
                        x: 1,
                        y: 0
                    },
                    stdY = {
                        x: 0,
                        y: 1
                    };
                let c1 = stdX,
                    c2 = stdY;
                if (this.deps[0]) {
                    const mat = this.deps[0];
                    c1 = MathLib.lerp(stdX, mat.c1, t);
                    c2 = MathLib.lerp(stdY, mat.c2, t)
                }
                ctx.save();
                ctx.globalAlpha = 0.3 * (1 - t);
                const stdAxisColors = ["#94a3b8", "#94a3b8"];
                [stdX, stdY].forEach((v, i) => {
                    ctx.beginPath();
                    ctx.moveTo(o.x, o.y);
                    const end = view.toScreen(MathLib.add(this.origin, MathLib.scale(v, 3)));
                    ctx.lineTo(end.x, end.y);
                    ctx.strokeStyle = stdAxisColors[i];
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    drawArrowHead(ctx, o, end, stdAxisColors[i])
                });
                ctx.restore();
                const axisColors = ["#a78bfa", "#a78bfa"];
                [c1, c2].forEach((v, i) => {
                    ctx.beginPath();
                    ctx.moveTo(o.x, o.y);
                    const end = view.toScreen(MathLib.add(this.origin, MathLib.scale(v, 3)));
                    ctx.lineTo(end.x, end.y);
                    ctx.strokeStyle = axisColors[i];
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.85;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    drawArrowHead(ctx, o, end, axisColors[i])
                });
                ctx.save();
                ctx.lineWidth = 1;
                ctx.strokeStyle = "#a78bfa";
                ctx.globalAlpha = 0.25 * t;
                const range = 10;
                for (let i = -range; i <= range; i++) {
                    let p1 = MathLib.add(this.origin, MathLib.add(MathLib.scale(c1, i), MathLib.scale(c2, -range)));
                    let p2 = MathLib.add(this.origin, MathLib.add(MathLib.scale(c1, i), MathLib.scale(c2, range)));
                    let s1 = view.toScreen(p1),
                        s2 = view.toScreen(p2);
                    ctx.beginPath();
                    ctx.moveTo(s1.x, s1.y);
                    ctx.lineTo(s2.x, s2.y);
                    ctx.stroke();
                    p1 = MathLib.add(this.origin, MathLib.add(MathLib.scale(c2, i), MathLib.scale(c1, -range)));
                    p2 = MathLib.add(this.origin, MathLib.add(MathLib.scale(c2, i), MathLib.scale(c1, range)));
                    s1 = view.toScreen(p1);
                    s2 = view.toScreen(p2);
                    ctx.beginPath();
                    ctx.moveTo(s1.x, s1.y);
                    ctx.lineTo(s2.x, s2.y);
                    ctx.stroke()
                }
                ctx.restore();
                if (this.eigen.length > 0) {
                    this.eigen.forEach((e, idx) => {
                        const color = idx === 0 ? "#dc2626" : "#0284c7";
                        ctx.save();
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 1.5;
                        ctx.setLineDash([2, 2]);
                        ctx.globalAlpha = 0.65;
                        const lineRange = 100;
                        const p1 = MathLib.add(this.origin, MathLib.scale(e.vec, -lineRange));
                        const p2 = MathLib.add(this.origin, MathLib.scale(e.vec, lineRange));
                        const s1 = view.toScreen(p1),
                            s2 = view.toScreen(p2);
                        ctx.beginPath();
                        ctx.moveTo(s1.x, s1.y);
                        ctx.lineTo(s2.x, s2.y);
                        ctx.stroke();
                        ctx.restore();
                        const color2 = idx === 0 ? "#4ade80" : "#fb923c";
                        const end = view.toScreen(MathLib.add(this.origin, MathLib.scale(e.vec, e.val)));
                        ctx.beginPath();
                        ctx.moveTo(o.x, o.y);
                        ctx.lineTo(end.x, end.y);
                        ctx.strokeStyle = this.selected ? "#eab308" : color2;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 3]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        drawArrowHead(ctx, o, end, ctx.strokeStyle);
                        ctx.fillStyle = color2;
                        ctx.font = "11px sans-serif";
                        ctx.fillText(`Î»=${e.val.toFixed(2)}`, end.x, end.y - 12)
                    });
                    if (this.eigen.length === 2) {
                        const ev1 = MathLib.scale(this.eigen[0].vec, this.eigen[0].val),
                            ev2 = MathLib.scale(this.eigen[1].vec, this.eigen[1].val),
                            ep1 = view.toScreen(MathLib.add(this.origin, ev1)),
                            ep2 = view.toScreen(MathLib.add(this.origin, ev2)),
                            eSum = view.toScreen(MathLib.add(this.origin, MathLib.add(ev1, ev2)));
                        ctx.beginPath();
                        ctx.moveTo(o.x, o.y);
                        ctx.lineTo(ep1.x, ep1.y);
                        ctx.lineTo(eSum.x, eSum.y);
                        ctx.lineTo(ep2.x, ep2.y);
                        ctx.closePath();
                        ctx.strokeStyle = "rgba(255,255,255,.6)";
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        ctx.setLineDash([]);
                        const eArea = Math.abs(MathLib.det(ev1, ev2));
                        ctx.fillStyle = "#fff";
                        ctx.fillText(`EigArea: ${eArea.toFixed(1)}`, eSum.x, eSum.y + 12)
                    }
                }
            }
            hitTest(s, w, v) {
                const p = v.toScreen(this.origin);
                return (s.x - p.x) ** 2 + (s.y - p.y) ** 2 < 100
            }
        }
        class TransformedVector extends SceneObject {
            constructor(mat, vec) {
                super("trans_vec");
                if (mat && vec) {
                    this.deps = [mat, vec]
                } else {
                    this.deps = []
                }
                this.label = vec ? vec.label + "'" : "?'";
                this.color = vec ? vec.color : "#fff";
                this.animState = {
                    t: 1
                };
                this.update()
            }
            getZIndex() {
                return 3
            }
            update() {
                if (!this.deps[0] || !this.deps[1]) return;
                this.origin = this.deps[1].origin;
                const m = this.deps[0],
                    orig = this.deps[1].vec;
                this.A = {
                    c1: m.c1,
                    c2: m.c2
                };
                if (Math.abs(m.det) > 1e-4) {
                    this.svdRes = MathLib.svd(this.A.c1, this.A.c2);
                    this.U = this.svdRes.U;
                    this.S = this.svdRes.S;
                    this.V = this.svdRes.V;
                    this.VT = MathLib.matTrans(this.V.c1, this.V.c2)
                } else {
                    this.U = {
                        c1: {
                            x: 1,
                            y: 0
                        },
                        c2: {
                            x: 0,
                            y: 1
                        }
                    };
                    this.S = this.A;
                    this.VT = {
                        c1: {
                            x: 1,
                            y: 0
                        },
                        c2: {
                            x: 0,
                            y: 1
                        }
                    }
                }
                this.vecStart = orig;
                this.vecMid1 = MathLib.transform(orig, this.VT.c1, this.VT.c2);
                this.vecMid2 = MathLib.transform(this.vecMid1, this.S.c1, this.S.c2);
                this.vecEnd = MathLib.transform(orig, this.A.c1, this.A.c2);
                this.originalLen = MathLib.len(orig);
                this.ang1 = Math.atan2(this.VT.c1.y, this.VT.c1.x);
                this.ang2 = Math.atan2(this.U.c1.y, this.U.c1.x);
                this.angleDeg1 = (this.ang1 * 180 / Math.PI).toFixed(1);
                this.angleDeg2 = (this.ang2 * 180 / Math.PI).toFixed(1);
                const t = this.animState.t;
                if (t < 0.3) {
                    const p = t / 0.3;
                    this.vec = MathLib.rotateVec(this.vecStart, this.ang1 * p);
                    this.phaseLabel = "1. æ—‹è½¬ (Rotate Váµ€)"
                } else if (t < 0.6) {
                    const p = (t - 0.3) / 0.3;
                    this.vec = MathLib.lerp(this.vecMid1, this.vecMid2, p);
                    this.phaseLabel = "2. æ‹‰ä¼¸ (Scale Î£)"
                } else if (t < 0.9) {
                    const p = (t - 0.6) / 0.3;
                    this.vec = MathLib.rotateVec(this.vecMid2, this.ang2 * p);
                    this.phaseLabel = "3. æ—‹è½¬ (Rotate U)"
                } else {
                    this.vec = this.vecEnd;
                    this.phaseLabel = "å®Œæˆ (Done)"
                }
                this.len = MathLib.len(this.vec);
                this.scaleRatio = this.originalLen > 1e-3 ? (this.len / this.originalLen).toFixed(2) : "âˆ"
            }
            render(ctx, view) {
                const mat = this.deps[0],
                    s = view.toScreen(this.origin),
                    e = view.toScreen(MathLib.add(this.origin, this.vec));
                const range = 20;
                ctx.lineWidth = 1;
                ctx.strokeStyle = "rgba(167,139,250,.4)";
                ctx.beginPath();
                for (let i = -range; i <= range; i++) {
                    const pStart1 = MathLib.add(this.origin, MathLib.add(MathLib.scale(mat.c1, i), MathLib.scale(mat.c2, -range))),
                        pEnd1 = MathLib.add(this.origin, MathLib.add(MathLib.scale(mat.c1, i), MathLib.scale(mat.c2, range))),
                        sStart1 = view.toScreen(pStart1),
                        sEnd1 = view.toScreen(pEnd1);
                    ctx.moveTo(sStart1.x, sStart1.y);
                    ctx.lineTo(sEnd1.x, sEnd1.y);
                    const pStart2 = MathLib.add(this.origin, MathLib.add(MathLib.scale(mat.c2, i), MathLib.scale(mat.c1, -range))),
                        pEnd2 = MathLib.add(this.origin, MathLib.add(MathLib.scale(mat.c2, i), MathLib.scale(mat.c1, range))),
                        sStart2 = view.toScreen(pStart2),
                        sEnd2 = view.toScreen(pEnd2);
                    ctx.moveTo(sStart2.x, sStart2.y);
                    ctx.lineTo(sEnd2.x, sEnd2.y)
                }
                ctx.stroke();
                const sC1 = view.toScreen(MathLib.add(this.origin, mat.c1)),
                    sC2 = view.toScreen(MathLib.add(this.origin, mat.c2));
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(sC1.x, sC1.y);
                ctx.strokeStyle = "#a78bfa";
                ctx.lineWidth = 2.5;
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(sC2.x, sC2.y);
                ctx.strokeStyle = "#a78bfa";
                ctx.lineWidth = 2.5;
                ctx.stroke();
                if (this.animState.t < 1) {
                    const globalOpacity = this.animState.t > 0.9 ? 1 - (this.animState.t - 0.9) / 0.1 : 1;
                    if (this.animState.t > 0) {
                        const opacity = (this.animState.t < 0.3 ? 1 : 0.3) * globalOpacity;
                        const tRot = Math.min(1, this.animState.t / 0.3);
                        const sEnd = view.toScreen(MathLib.add(this.origin, this.vecMid1));
                        const r = Math.hypot(sEnd.x - s.x, sEnd.y - s.y);
                        if (r > 10) {
                            const startAng = Math.atan2(view.toScreen(MathLib.add(this.origin, this.vecStart)).y - s.y, view.toScreen(MathLib.add(this.origin, this.vecStart)).x - s.x);
                            const deltaAng = -this.ang1 * tRot;
                            ctx.beginPath();
                            ctx.arc(s.x, s.y, r, startAng, startAng + deltaAng, this.ang1 > 0);
                            ctx.strokeStyle = `rgba(251, 191, 36, ${opacity})`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            const currentAng = startAng + deltaAng;
                            const ahX = s.x + r * Math.cos(currentAng),
                                ahY = s.y + r * Math.sin(currentAng);
                            drawArrowHead(ctx, {
                                x: s.x + r * Math.cos(currentAng + 0.1 * (this.ang1 > 0 ? 1 : -1)),
                                y: s.y + r * Math.sin(currentAng + 0.1 * (this.ang1 > 0 ? 1 : -1))
                            }, {
                                x: ahX,
                                y: ahY
                            }, `rgba(251, 191, 36, ${opacity})`);
                            if (this.animState.t >= 0.3) {
                                const pEndVec = view.toScreen(MathLib.add(this.origin, this.vecMid1));
                                ctx.beginPath();
                                ctx.moveTo(s.x, s.y);
                                ctx.lineTo(pEndVec.x, pEndVec.y);
                                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                                ctx.setLineDash([4, 4]);
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                ctx.setLineDash([])
                            }
                        }
                    }
                    if (this.animState.t > 0.3) {
                        const opacity = (this.animState.t < 0.6 ? 1 : 0.3) * globalOpacity;
                        if (this.eigS) {
                            this.eigS.forEach(eg => {
                                const vRot = MathLib.rotateVec(eg.vec, this.ang1);
                                const pEnd = view.toScreen(MathLib.add(this.origin, MathLib.scale(vRot, 3)));
                                const pStart = view.toScreen(MathLib.add(this.origin, MathLib.scale(vRot, -3)));
                                ctx.beginPath();
                                ctx.moveTo(pStart.x, pStart.y);
                                ctx.lineTo(pEnd.x, pEnd.y);
                                ctx.strokeStyle = `rgba(34, 211, 238, ${opacity*0.5})`;
                                ctx.setLineDash([4, 4]);
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                ctx.setLineDash([])
                            })
                        }
                        const pMid1 = view.toScreen(MathLib.add(this.origin, this.vecMid1));
                        const pMid2 = view.toScreen(MathLib.add(this.origin, this.vecMid2));
                        ctx.beginPath();
                        ctx.moveTo(pMid1.x, pMid1.y);
                        ctx.lineTo(pMid2.x, pMid2.y);
                        ctx.setLineDash([4, 4]);
                        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.setLineDash([]);
                        if (this.animState.t >= 0.6) {
                            const pEndVec = view.toScreen(MathLib.add(this.origin, this.vecMid2));
                            ctx.beginPath();
                            ctx.moveTo(s.x, s.y);
                            ctx.lineTo(pEndVec.x, pEndVec.y);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                            ctx.setLineDash([4, 4]);
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            ctx.setLineDash([])
                        }
                    }
                    if (this.animState.t > 0.6) {
                        const opacity = globalOpacity;
                        const tRot = Math.min(1, (this.animState.t - 0.6) / 0.3);
                        const sEnd = view.toScreen(MathLib.add(this.origin, this.vecEnd));
                        const r = Math.hypot(sEnd.x - s.x, sEnd.y - s.y);
                        if (r > 10) {
                            const startAng = Math.atan2(view.toScreen(MathLib.add(this.origin, this.vecMid2)).y - s.y, view.toScreen(MathLib.add(this.origin, this.vecMid2)).x - s.x);
                            const deltaAng = -this.ang2 * tRot;
                            ctx.beginPath();
                            ctx.arc(s.x, s.y, r, startAng, startAng + deltaAng, this.ang2 > 0);
                            ctx.strokeStyle = `rgba(251, 191, 36, ${opacity})`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            const currentAng = startAng + deltaAng;
                            const ahX = s.x + r * Math.cos(currentAng),
                                ahY = s.y + r * Math.sin(currentAng);
                            drawArrowHead(ctx, {
                                x: s.x + r * Math.cos(currentAng + 0.1 * (this.ang2 > 0 ? 1 : -1)),
                                y: s.y + r * Math.sin(currentAng + 0.1 * (this.ang2 > 0 ? 1 : -1))
                            }, {
                                x: ahX,
                                y: ahY
                            }, `rgba(251, 191, 36, ${opacity})`)
                        }
                    }
                }
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(e.x, e.y);
                ctx.strokeStyle = this.selected ? "#eab308" : this.color;
                ctx.lineWidth = 3;
                if (this.animState.t < 1) ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                drawArrowHead(ctx, s, e, ctx.strokeStyle);
                ctx.fillStyle = this.color;
                ctx.font = "11px sans-serif";
                const lbl = this.animState.t < 1 ? `${this.phaseLabel}` : `${this.label} (L=${this.len.toFixed(1)}, Scale=${this.scaleRatio})`;
                ctx.fillText(lbl, e.x + 8, e.y)
            }
            hitTest(s, w, v) {
                const p1 = v.toScreen(this.origin),
                    p2 = v.toScreen(MathLib.add(this.origin, this.vec));
                const l2 = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
                if (l2 === 0) return (s.x - p1.x) ** 2 + (s.y - p1.y) ** 2 < 64;
                let t = ((s.x - p1.x) * (p2.x - p1.x) + (s.y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const proj = {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
                return (s.x - proj.x) ** 2 + (s.y - proj.y) ** 2 < 64
            }
        }
        class TransformedMatrix extends SceneObject {
            constructor(matA, matB) {
                super("trans_mat");
                if (matA && matB) {
                    this.deps = [matA, matB]
                } else {
                    this.deps = []
                }
                this.label = `${matA.label}Â·${matB.label}`;
                this.animState = {
                    t: 1
                };
                this.update();
                this.triggerAnimation()
            }
            getZIndex() {
                return 3
            }
            triggerAnimation() {
                this.animState.t = 0;
                AnimationEngine.add({
                    duration: 8000,
                    onUpdate: t => this.animState.t = t
                })
            }
            update() {
                if (!this.deps[0] || !this.deps[1]) return;
                this.origin = this.deps[1].origin;
                const mA = this.deps[0],
                    mB = this.deps[1];
                this.A = {
                    c1: mA.c1,
                    c2: mA.c2
                };
                if (Math.abs(mA.det) > 1e-4) {
                    this.svdRes = MathLib.svd(this.A.c1, this.A.c2);
                    this.U = this.svdRes.U;
                    this.S = this.svdRes.S;
                    this.V = this.svdRes.V;
                    this.VT = MathLib.matTrans(this.V.c1, this.V.c2)
                } else {
                    this.U = {
                        c1: {
                            x: 1,
                            y: 0
                        },
                        c2: {
                            x: 0,
                            y: 1
                        }
                    };
                    this.S = this.A;
                    this.VT = {
                        c1: {
                            x: 1,
                            y: 0
                        },
                        c2: {
                            x: 0,
                            y: 1
                        }
                    }
                }
                this.B = {
                    c1: mB.c1,
                    c2: mB.c2
                };
                this.originalArea = mB.area;
                const t = this.animState.t;
                const applyTrans = (vec) => {
                    let vecMid1 = MathLib.transform(vec, this.VT.c1, this.VT.c2);
                    let vecMid2 = MathLib.transform(vecMid1, this.S.c1, this.S.c2);
                    let vecEnd = MathLib.transform(vec, this.A.c1, this.A.c2);
                    let ang1 = Math.atan2(this.VT.c1.y, this.VT.c1.x);
                    let ang2 = Math.atan2(this.U.c1.y, this.U.c1.x);
                    if (t < 0.3) {
                        const p = t / 0.3;
                        return MathLib.rotateVec(vec, ang1 * p)
                    } else if (t < 0.6) {
                        const p = (t - 0.3) / 0.3;
                        return MathLib.lerp(vecMid1, vecMid2, p)
                    } else if (t < 0.9) {
                        const p = (t - 0.6) / 0.3;
                        return MathLib.rotateVec(vecMid2, ang2 * p)
                    } else {
                        return vecEnd
                    }
                };
                this.c1 = applyTrans(this.B.c1);
                this.c2 = applyTrans(this.B.c2);
                this.det = MathLib.det(this.c1, this.c2);
                this.area = Math.abs(this.det);
                this.scaleRatio = this.originalArea > 1e-3 ? (this.area / this.originalArea).toFixed(2) : "âˆ";
                this.angleDeg1 = (Math.atan2(this.VT.c1.y, this.VT.c1.x) * 180 / Math.PI).toFixed(1);
                this.angleDeg2 = (Math.atan2(this.U.c1.y, this.U.c1.x) * 180 / Math.PI).toFixed(1);
                const ev = MathLib.solveEigen(this.S.c1, this.S.c2);
                this.stretchDesc = ev.map(e => e.val.toFixed(2)).join(", ");
                if (t < 0.3) this.phaseLabel = "1. æ—‹è½¬ (Rotate Váµ€)";
                else if (t < 0.6) this.phaseLabel = "2. æ‹‰ä¼¸ (Scale Î£)";
                else if (t < 0.9) this.phaseLabel = "3. æ—‹è½¬ (Rotate U)";
                else this.phaseLabel = "å®Œæˆ (Done)"
            }
            render(ctx, view) {
                const o = view.toScreen(this.origin),
                    p1 = view.toScreen(MathLib.add(this.origin, this.c1)),
                    p2 = view.toScreen(MathLib.add(this.origin, this.c2)),
                    pSum = view.toScreen(MathLib.add(this.origin, MathLib.add(this.c1, this.c2)));
                ctx.beginPath();
                ctx.moveTo(o.x, o.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.lineTo(pSum.x, pSum.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.closePath();
                ctx.fillStyle = this.selected ? "rgba(234,179,8,.3)" : "rgba(16,185,129,.2)";
                ctx.fill();
                ctx.strokeStyle = this.selected ? "#eab308" : "rgba(16,185,129,.5)";
                ctx.lineWidth = 1.5;
                ctx.stroke();
                drawArrowHead(ctx, o, p1, ctx.strokeStyle);
                drawArrowHead(ctx, o, p2, ctx.strokeStyle);
                ctx.fillStyle = "#a7f3d0";
                ctx.font = "11px sans-serif";
                const lbl = this.animState.t < 1 ? `${this.phaseLabel}` : `${this.label} (Area=${this.area.toFixed(1)}, Scale=${this.scaleRatio})`;
                ctx.fillText(lbl, pSum.x + 5, pSum.y)
            }
            hitTest(s, w, v) {
                const dx = w.x - this.origin.x,
                    dy = w.y - this.origin.y,
                    det = this.c1.x * this.c2.y - this.c1.y * this.c2.x;
                if (Math.abs(det) < 1e-9) return false;
                const u = (dx * this.c2.y - dy * this.c2.x) / det,
                    v_ = (this.c1.x * dy - this.c1.y * dx) / det;
                return u >= 0 && u <= 1 && v_ >= 0 && v_ <= 1
            }
        }
        class LinearComb extends SceneObject {
            constructor(vectors) {
                super("lin_comb");
                this.deps = [...vectors];
                this.coeffs = new Array(vectors.length).fill(1);
                this.animState = {
                    active: false,
                    t: 0
                };
                this.update()
            }
            getZIndex() {
                return 4
            }
            update() {
                if (this.deps.length === 0) return;
                this.origin = this.deps[0].origin;
                let res = {
                    x: 0,
                    y: 0
                };
                this.deps.forEach((v, i) => {
                    if (v && v.vec) res = MathLib.add(res, MathLib.scale(v.vec, this.coeffs[i]))
                });
                this.vec = res
            }
            render(ctx, view) {
                const s = view.toScreen(this.origin),
                    e = view.toScreen(MathLib.add(this.origin, this.vec));
                ctx.setLineDash([2, 2]);
                ctx.lineWidth = 1;
                if (this.deps.length === 2) {
                    const v1Scaled = MathLib.scale(this.deps[0].vec, this.coeffs[0]);
                    const v2Scaled = MathLib.scale(this.deps[1].vec, this.coeffs[1]);
                    const p1 = view.toScreen(MathLib.add(this.origin, v1Scaled)),
                        p2 = view.toScreen(MathLib.add(this.origin, v2Scaled));
                    ctx.strokeStyle = "rgba(255,255,255,.2)";
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(p1.x, p1.y);
                    ctx.lineTo(e.x, e.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(e.x, e.y);
                    ctx.stroke();
                    if (this.animState.active) {
                        const movingOrigin = MathLib.lerp(this.origin, MathLib.add(this.origin, v1Scaled), this.animState.t);
                        const movingTip = MathLib.add(movingOrigin, v2Scaled);
                        const ms = view.toScreen(movingOrigin),
                            me = view.toScreen(movingTip);
                        ctx.beginPath();
                        ctx.moveTo(ms.x, ms.y);
                        ctx.lineTo(me.x, me.y);
                        ctx.strokeStyle = `rgba(255, 255, 255, 0.7)`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([]);
                        ctx.stroke();
                        drawArrowHead(ctx, ms, me, ctx.strokeStyle);
                        ctx.fillStyle = "rgba(255,255,255,0.8)";
                        ctx.font = "10px sans-serif";
                        ctx.fillText("å¹³ç§»ä¸­...", me.x + 5, me.y)
                    }
                } else {
                    let curW = this.origin,
                        curS = s;
                    this.deps.forEach((v, i) => {
                        const step = MathLib.scale(v.vec, this.coeffs[i]),
                            nextW = MathLib.add(curW, step),
                            nextS = view.toScreen(nextW);
                        ctx.beginPath();
                        ctx.moveTo(curS.x, curS.y);
                        ctx.lineTo(nextS.x, nextS.y);
                        ctx.strokeStyle = v.color || "#fff";
                        ctx.stroke();
                        drawArrowHead(ctx, curS, nextS, ctx.strokeStyle);
                        curW = nextW;
                        curS = nextS
                    })
                }
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(s.x, s.y);
                ctx.lineTo(e.x, e.y);
                ctx.strokeStyle = this.selected ? "#eab308" : "#22d3ee";
                ctx.lineWidth = 3;
                ctx.stroke();
                drawArrowHead(ctx, s, e, ctx.strokeStyle);
                ctx.fillStyle = this.color;
                ctx.font = "11px sans-serif";
                const lbl = this.animState.t < 1 ? `${this.phaseLabel}` : `${this.label} (L=${this.len.toFixed(1)}, Scale=${this.scaleRatio})`;
                ctx.fillText(lbl, e.x + 8, e.y)
            }
            hitTest(s, w, v) {
                const p1 = v.toScreen(this.origin),
                    p2 = v.toScreen(MathLib.add(this.origin, this.vec));
                const l2 = (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
                if (l2 === 0) return (s.x - p1.x) ** 2 + (s.y - p1.y) ** 2 < 64;
                let t = ((s.x - p1.x) * (p2.x - p1.x) + (s.y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const proj = {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
                return (s.x - proj.x) ** 2 + (s.y - proj.y) ** 2 < 64
            }
        }

        function drawArrowHead(ctx, start, end, color) {
            const a = Math.atan2(end.y - start.y, end.x - start.x);
            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(end.x - 10 * Math.cos(a - Math.PI / 6), end.y - 10 * Math.sin(a - Math.PI / 6));
            ctx.lineTo(end.x - 10 * Math.cos(a + Math.PI / 6), end.y - 10 * Math.sin(a + Math.PI / 6));
            ctx.fillStyle = color;
            ctx.fill()
        }
        const app = {
            objects: [],
            selection: [],
            view: {
                cx: 0,
                cy: 0,
                zoom: 40
            },
            add(o) {
                this.objects.push(o);
                this.render();
                this.updateUI();
                historyManager.saveState()
            },
            reset() {
                this.objects = [];
                this.selection = [];
                OBJ_ID = 1;
                historyManager.clear();
                this.render();
                this.updateUI();
                historyManager.saveState()
            },
            resetView() {
                this.view = {
                    cx: 0,
                    cy: 0,
                    zoom: 40
                };
                this.render()
            },
            select(o, multi) {
                if (!multi) this.selection = [];
                if (o && !this.selection.includes(o)) this.selection.push(o);
                this.objects.forEach(x => x.selected = this.selection.includes(x));
                this.updateUI();
                this.render()
            },
            remove(o) {
                const toRemove = [o];
                let changed = true;
                while (changed) {
                    changed = false;
                    this.objects.forEach(x => {
                        if (!toRemove.includes(x) && x.deps.some(d => toRemove.includes(d))) {
                            toRemove.push(x);
                            changed = true
                        }
                    })
                }
                this.objects = this.objects.filter(x => !toRemove.includes(x));
                this.selection = this.selection.filter(x => !toRemove.includes(x));
                this.updateUI();
                this.render();
                historyManager.saveState()
            },
            updateUI() {
                document.getElementById("object-list").innerHTML = this.objects.map(o => `<div class="obj-item ${o.selected?"selected":""}" onclick="app.clickList('${o.id}', event)"><span>${o.label} <span style="color:#64748b;font-size:10px">(${o.type})</span></span></div>`).join("");
                const sel = this.selection,
                    types = sel.map(o => o.type);
                document.getElementById("btn-create-vec").disabled = !(sel.length === 2 && types.every(t => t === "point"));
                document.getElementById("btn-create-mat").disabled = !(sel.length === 2 && types.every(t => t === "vector"));
                document.getElementById("btn-lin-comb").disabled = !(sel.length >= 2 && types.every(t => t === "vector"));
                document.getElementById("btn-create-eigen").disabled = !(sel.length === 1 && types[0] === "matrix");
                document.getElementById("btn-apply-trans").disabled = !(sel.length === 2 && (types.includes("matrix") && (types.includes("vector") || types.filter(t => t === "matrix").length === 2)));
                const pPanel = document.getElementById("properties-panel");
                if (sel.length === 1) {
                    const o = sel[0];
                    let html = `<div style="margin-bottom:8px;font-weight:bold;color:var(--accent)">${o.label} <span style="font-size:11px;color:#64748b">(${o.type})</span></div>`;
                    if (o.type === "point") {
                        html += `<div class="prop-group"><div class="prop-row"><label>X</label><input type="number" step="0.1" value="${o.pos.x.toFixed(2)}" onchange="actions.movePoint('${o.id}', this.value, null)"></div><div class="prop-row"><label>Y</label><input type="number" step="0.1" value="${o.pos.y.toFixed(2)}" onchange="actions.movePoint('${o.id}', null, this.value)"></div></div>`
                    } else if (o.type === "vector" || o.type === "trans_vec") {
                        html += `<div class="prop-group"><div class="prop-row"><label>X</label><input disabled value="${o.vec.x.toFixed(2)}"></div><div class="prop-row"><label>Y</label><input disabled value="${o.vec.y.toFixed(2)}"></div><div class="prop-row"><label>Len</label><input disabled value="${o.len.toFixed(2)}"></div>${o.type==="trans_vec"?`<div class="prop-row"><label>Scale</label><input disabled value="${o.scaleRatio}"></div>`:""}<div class="prop-row"><label>Color</label><input type="color" value="${o.color||'#ffffff'}" onchange="actions.updateColor('${o.id}', this.value)"></div></div>`
                    } else if (o.type === "matrix") {
                        html += `<div class="prop-group"><div style="font-size:10px;color:#94a3b8;margin-bottom:4px">çŸ©é˜µå€¼</div><div class="matrix-grid"><div class="matrix-val">${o.c1.x.toFixed(1)}</div><div class="matrix-val">${o.c2.x.toFixed(1)}</div><div class="matrix-val">${o.c1.y.toFixed(1)}</div><div class="matrix-val">${o.c2.y.toFixed(1)}</div></div><div class="prop-row"><label>Det</label><input disabled value="${o.det.toFixed(2)}"></div><div class="prop-row"><label>Color</label><input type="color" value="${o.color||'#7c3aed'}" onchange="actions.updateColor('${o.id}', this.value)"></div></div><div class="prop-group"><div style="font-size:10px;color:#94a3b8;margin-bottom:4px">ç‰¹å¾ç³»ç»Ÿ</div>${o.eigen.map((e,i)=>`<div style="margin-bottom:6px;border-top:1px solid #334155;padding-top:4px"><div class="prop-row"><span style="color:${i==0?"#4ade80":"#fb923c"}">Î»${i+1}</span> <span>= ${e.val.toFixed(2)}</span></div><div class="prop-row" style="color:#94a3b8;font-size:10px">v: [${e.vec.x.toFixed(2)}, ${e.vec.y.toFixed(2)}]</div></div>`).join("")||'<div style="color:#64748b;font-size:11px">æ— å®ç‰¹å¾å€¼</div>'}</div>`
                    } else if (o.type === "eigen") {
                        html += `<div class="prop-group"><div style="font-size:10px;color:#94a3b8;margin-bottom:4px">ç‰¹å¾åˆ†æç»“æœ</div>${o.eigen.map((e,i)=>`<div style="margin-bottom:6px;border-top:1px solid #334155;padding-top:4px"><div class="prop-row"><span style="color:${i==0?"#4ade80":"#fb923c"}">Î»${i+1}</span> <span>= ${e.val.toFixed(2)}</span></div><div class="prop-row" style="color:#94a3b8;font-size:10px">v: [${e.vec.x.toFixed(2)}, ${e.vec.y.toFixed(2)}]</div></div>`).join("")||'<div style="color:#64748b;font-size:11px">æ— å®ç‰¹å¾å€¼</div>'}</div>`
                    } else if (o.type === "lin_comb") {
                        html += `<div class="prop-group"><div class="prop-row"><label>Count</label><input disabled value="${o.deps.length}"></div></div>`
                    } else if (o.type === "trans_mat") {
                        html += `<div class="prop-group"><div class="prop-row"><label>Area</label><input disabled value="${o.area.toFixed(2)}"></div><div class="prop-row"><label>Scale</label><input disabled value="${o.scaleRatio}"></div></div>`
                    }
                    pPanel.innerHTML = html
                } else {
                    pPanel.innerHTML = '<div style="color:#64748b;font-size:12px;text-align:center">æœªé€‰æ‹©å¯¹è±¡</div>'
                }
                const combObj = sel.find(o => o.type === "lin_comb") || this.objects.find(o => o.type === "lin_comb"),
                    cCtrl = document.getElementById("comb-controls");
                if (combObj && sel.includes(combObj)) {
                    cCtrl.style.display = "flex";
                    let html = "";
                    combObj.coeffs.forEach((val, idx) => {
                        const valId = `comb-${combObj.id}-val-${idx}`;
                        html += `<div style="display:flex;flex-direction:column;align-items:center;gap:2px;"><span style="font-size:10px;color:#94a3b8;font-weight:bold;">k${idx+1}</span><input type="number" id="${valId}" value="${val.toFixed(1)}" min="-20" max="20" step="0.1" style="width:50px;text-align:center;font-size:12px;" onchange="actions.updateCombCoeff('${combObj.id}', ${idx}, this.value, '${valId}'); historyManager.saveState()"></div>`;
                        html += `<input type="range" min="-20" max="20" step="0.1" value="${val}" oninput="actions.updateCombCoeff('${combObj.id}', ${idx}, this.value, '${valId}')" onchange="historyManager.saveState()">`;
                        if (idx < combObj.coeffs.length - 1) {
                            html += `<div style="width:1px;height:30px;background:#475569;"></div>`
                        }
                    });
                    if (combObj.deps.length === 2) {
                        html += `<div style="width:1px;height:30px;background:#475569;"></div><button class="anim-btn" onclick="actions.animateComb('${combObj.id}')">â–¶ æ¼”ç¤ºå¹³ç§»</button>`
                    }
                    cCtrl.innerHTML = html
                } else {
                    cCtrl.style.display = "none"
                }
                const transVec = sel.find(o => o.type === "trans_vec");
                const transMat = sel.find(o => o.type === "trans_mat");
                const tCtrl = document.getElementById("trans-controls");
                if ((transVec || transMat) && sel.length === 1) {
                    const obj = transVec || transMat;
                    tCtrl.style.display = "flex";
                    const toHTML = m => `<div class="math-matrix"><div>${m.c1.x.toFixed(2)}</div><div>${m.c2.x.toFixed(2)}</div><div>${m.c1.y.toFixed(2)}</div><div>${m.c2.y.toFixed(2)}</div></div>`;
                    let html = `<div style="display:flex;align-items:center;gap:12px;color:#fff;font-size:14px;background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;">`;
                    html += `<div>${toHTML(obj.A)}</div>`;
                    html += `<div>=</div>`;
                    html += `<div style="display:flex;flex-direction:column;align-items:center;"><span style="font-size:9px;color:#cbd5e1;margin-bottom:2px">æ—‹è½¬ (U)</span>${toHTML(obj.U)}<div class="matrix-desc"><em>Î¸â‚‚ â‰ˆ ${obj.angleDeg2}Â°</em><br>Output Rotation</div></div>`;
                    html += `<div>Ã—</div>`;
                    html += `<div style="display:flex;flex-direction:column;align-items:center;"><span style="font-size:9px;color:#cbd5e1;margin-bottom:2px">æ‹‰ä¼¸ (Î£)</span>${toHTML(obj.S)}<div class="matrix-desc"><em>Singular Values</em><br>Scaling</div></div>`;
                    html += `<div>Ã—</div>`;
                    html += `<div style="display:flex;flex-direction:column;align-items:center;"><span style="font-size:9px;color:#cbd5e1;margin-bottom:2px">æ—‹è½¬ (Váµ€)</span>${toHTML(obj.VT)}<div class="matrix-desc"><em>Î¸â‚ â‰ˆ ${obj.angleDeg1}Â°</em><br>Input Rotation</div></div>`;
                    html += `<div style="width:1px;height:50px;background:#475569;margin:0 10px;"></div>`;
                    html += `<button class="anim-btn" onclick="actions.animateTrans('${obj.id}')">â–¶ æ¼”ç¤ºå˜æ¢</button>`;
                    html += `</div>`;
                    tCtrl.innerHTML = html
                } else {
                    tCtrl.style.display = "none"
                }
            },
            clickList(id, e) {
                const o = this.objects.find(x => x.id === id);
                this.select(o, e.ctrlKey)
            },
            render() {
                const ctx = canvas.getContext("2d"),
                    {
                        width,
                        height
                    } = canvas;
                ctx.clearRect(0, 0, width, height);
                const view = {
                    toScreen: p => ({
                        x: width / 2 + (p.x - this.view.cx) * this.view.zoom,
                        y: height / 2 - (p.y - this.view.cy) * this.view.zoom
                    }),
                    toWorld: s => ({
                        x: this.view.cx + (s.x - width / 2) / this.view.zoom,
                        y: this.view.cy - (s.y - height / 2) / this.view.zoom
                    })
                };
                drawGrid(ctx, view, width, height);
                [...this.objects].sort((a, b) => a.getZIndex() - b.getZIndex()).forEach(o => {
                    o.update();
                    o.render(ctx, view)
                })
            }
        };
        const actions = {
            createVector() {
                const vec = new Vector(app.selection[0], app.selection[1]);
                app.add(vec)
            },
            createMatrix() {
                const v1 = app.selection[0];
                const v2 = app.selection[1];
                const translation = MathLib.sub(v1.deps[0].pos, v2.deps[0].pos);
                const newStart = MathLib.add(v2.deps[0].pos, translation);
                const newEnd = MathLib.add(v2.deps[1].pos, translation);
                v2.deps[0].pos = newStart;
                v2.deps[1].pos = newEnd;
                v2.update();
                app.add(new Matrix(v1, v2))
            },
            createLinComb() {
                const vectors = app.selection;
                if (vectors.length >= 2) {
                    const firstVecStart = vectors[0].deps[0].pos;
                    for (let i = 1; i < vectors.length; i++) {
                        const v = vectors[i];
                        const currentStart = v.deps[0].pos;
                        const translation = MathLib.sub(firstVecStart, currentStart);
                        const newStart = MathLib.add(currentStart, translation);
                        const newEnd = MathLib.add(v.deps[1].pos, translation);
                        v.deps[0].pos = newStart;
                        v.deps[1].pos = newEnd;
                        v.update()
                    }
                }
                const comb = new LinearComb(app.selection);
                app.add(comb)
            },
            createEigen() {
                const eigen = new EigenSystem(app.selection[0]);
                app.add(eigen)
            },
            applyTransform() {
                const sel = app.selection;
                if (sel.length === 2) {
                    if (sel[0].type === 'matrix' && sel[1].type === 'vector') {
                        app.add(new TransformedVector(sel[0], sel[1]))
                    } else if (sel[0].type === 'matrix' && sel[1].type === 'matrix') {
                        app.add(new TransformedMatrix(sel[0], sel[1]))
                    }
                }
            },
            movePoint(id, x, y) {
                const p = app.objects.find(o => o.id === id);
                if (p) {
                    if (x !== null) p.pos.x = parseFloat(x);
                    if (y !== null) p.pos.y = parseFloat(y);
                    app.render();
                    historyManager.saveState()
                }
            },
            updateCombCoeff(id, idx, val, displayId) {
                const o = app.objects.find(x => x.id === id);
                if (o && o.type === "lin_comb") {
                    const numVal = Math.max(-20, Math.min(20, parseFloat(val)));
                    o.coeffs[idx] = numVal;
                    const disp = document.getElementById(displayId);
                    if (disp) {
                        disp.value = numVal.toFixed(1)
                    }
                    const rangeInput = disp ? disp.parentElement.nextElementSibling : null;
                    if (rangeInput && rangeInput.type === "range") {
                        rangeInput.value = numVal
                    }
                    app.render()
                }
            },
            updateColor(id, color) {
                const o = app.objects.find(o => o.id === id);
                if (o) {
                    o.color = color;
                    app.render();
                    historyManager.saveState()
                }
            },
            deleteSelected() {
                const sel = [...app.selection];
                sel.forEach(o => app.remove(o));
                hideCtxMenu()
            },
            animateComb(id) {
                const o = app.objects.find(x => x.id === id);
                if (o && o.type === "lin_comb") {
                    o.animState.active = true;
                    AnimationEngine.add({
                        duration: 1500,
                        onUpdate: t => {
                            o.animState.t = t
                        },
                        onComplete: () => {
                            o.animState.active = false;
                            o.animState.t = 0;
                            app.render()
                        }
                    })
                }
            },
            animateTrans(id) {
                const o = app.objects.find(x => x.id === id);
                if (o && (o.type === "trans_vec" || o.type === "trans_mat")) {
                    o.animState.t = 0;
                    AnimationEngine.add({
                        duration: 8000,
                        onUpdate: t => {
                            o.animState.t = t
                        },
                        onComplete: () => {
                            o.animState.t = 1;
                            app.render()
                        }
                    })
                }
            }
        };

        function drawGrid(ctx, view, w, h) {
            ctx.lineWidth = 1;
            ctx.strokeStyle = "#334155";
            ctx.globalAlpha = .4;
            const tl = view.toWorld({
                    x: 0,
                    y: 0
                }),
                br = view.toWorld({
                    x: w,
                    y: h
                });
            ctx.beginPath();
            for (let x = Math.floor(tl.x); x <= Math.ceil(br.x); x++) {
                const p = view.toScreen({
                    x,
                    y: 0
                });
                ctx.moveTo(p.x, 0);
                ctx.lineTo(p.x, h)
            }
            for (let y = Math.floor(br.y); y <= Math.ceil(tl.y); y++) {
                const p = view.toScreen({
                    x: 0,
                    y
                });
                ctx.moveTo(0, p.y);
                ctx.lineTo(w, p.y)
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
            const o = view.toScreen({
                x: 0,
                y: 0
            });
            ctx.strokeStyle = "#94a3b8";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, o.y);
            ctx.lineTo(w, o.y);
            ctx.moveTo(o.x, 0);
            ctx.lineTo(o.x, h);
            ctx.stroke()
        }
        const canvas = document.getElementById("canvas"),
            ctxMenu = document.getElementById("context-menu");
        let dragging = null,
            isPanning = false,
            lastPos = {
                x: 0,
                y: 0
            },
            dragStartPos = null;

        function resize() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            app.render()
        }
        window.addEventListener("resize", resize);
        setTimeout(resize, 0);
        window.addEventListener("click", hideCtxMenu);

        function hideCtxMenu() {
            ctxMenu.style.display = "none"
        }
        canvas.addEventListener("mousedown", e => {
            hideCtxMenu();
            const rect = canvas.getBoundingClientRect(),
                m = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            lastPos = m;
            if (e.button === 1) {
                isPanning = true;
                e.preventDefault();
                return
            }
            if (e.button === 2) return;
            const v = app.view,
                viewHelper = {
                    toScreen: p => ({
                        x: canvas.width / 2 + (p.x - v.cx) * v.zoom,
                        y: canvas.height / 2 - (p.y - v.cy) * v.zoom
                    }),
                    toWorld: s => ({
                        x: v.cx + (s.x - canvas.width / 2) / v.zoom,
                        y: v.cy - (s.y - canvas.height / 2) / v.zoom
                    })
                },
                w = viewHelper.toWorld(m),
                hit = [...app.objects].sort((a, b) => b.getZIndex() - a.getZIndex()).find(o => o.hitTest(m, w, viewHelper));
            if (hit) {
                app.select(hit, e.ctrlKey);
                if (hit.type === "point") {
                    dragging = hit;
                    dragStartPos = {
                        x: hit.pos.x,
                        y: hit.pos.y
                    }
                }
            } else {
                const sx = e.altKey ? w.x : snapIfNear(w.x),
                    sy = e.altKey ? w.y : snapIfNear(w.y);
                app.add(new Point(sx, sy))
            }
        });
        canvas.addEventListener("mousemove", e => {
            const rect = canvas.getBoundingClientRect(),
                m = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            if (isPanning) {
                app.view.cx -= (m.x - lastPos.x) / app.view.zoom;
                app.view.cy += (m.y - lastPos.y) / app.view.zoom;
                lastPos = m;
                app.render();
                return
            }
            if (dragging) {
                const v = app.view,
                    w = {
                        x: v.cx + (m.x - canvas.width / 2) / v.zoom,
                        y: v.cy - (m.y - canvas.height / 2) / v.zoom
                    };
                if (!e.altKey) {
                    w.x = snapIfNear(w.x);
                    w.y = snapIfNear(w.y)
                }
                dragging.pos = w;
                app.updateUI();
                app.render()
            }
        });
        canvas.addEventListener("mouseup", () => {
            if (dragging && dragStartPos) {
                const currentPos = dragging.pos;
                if (Math.abs(currentPos.x - dragStartPos.x) > 0.001 || Math.abs(currentPos.y - dragStartPos.y) > 0.001) {
                    historyManager.saveState()
                }
                dragStartPos = null
            }
            isPanning = false;
            dragging = null
        });
        canvas.addEventListener("contextmenu", e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect(),
                m = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                },
                v = app.view,
                viewHelper = {
                    toScreen: p => ({
                        x: canvas.width / 2 + (p.x - v.cx) * v.zoom,
                        y: canvas.height / 2 - (p.y - v.cy) * v.zoom
                    }),
                    toWorld: s => ({
                        x: v.cx + (s.x - canvas.width / 2) / v.zoom,
                        y: v.cy - (s.y - canvas.height / 2) / v.zoom
                    })
                },
                w = viewHelper.toWorld(m),
                hit = [...app.objects].sort((a, b) => b.getZIndex() - a.getZIndex()).find(o => o.hitTest(m, w, viewHelper));
            if (hit) app.select(hit);
            else app.select(null);
            ctxMenu.style.display = "block";
            ctxMenu.style.left = e.clientX + "px";
            ctxMenu.style.top = e.clientY + "px"
        });
        canvas.addEventListener("wheel", e => {
            e.preventDefault();
            const s = e.deltaY > 0 ? .9 : 1.1;
            app.view.zoom = Math.max(5, Math.min(200, app.view.zoom * s));
            app.render()
        }, {
            passive: false
        });
        historyManager.init();
        // ===== èŠå¤©çª—å£å¯æ‹–åŠ¨ æ ¸å¿ƒä»£ç  start =====
        const chatContainer = document.getElementById('chat-container');
        let isDraging = false;
        let startClientX, startClientY;
        let moveX = 0, moveY = 0;

        // é¼ æ ‡æŒ‰ä¸‹ï¼šå¼€å§‹æ‹–åŠ¨ï¼Œåªè®°å½•åæ ‡ï¼Œä¸ä¿®æ”¹ä»»ä½•å®šä½å±æ€§
        chatContainer.addEventListener('mousedown', function(e) {
            // åªå…è®¸ç‚¹å‡» èŠå¤©çª—å£/æ¶ˆæ¯åŒº æ‹–åŠ¨ï¼Œè¾“å…¥æ¡†/å‘é€æŒ‰é’®ä¸å—å½±å“
            if (e.target.id === 'chat-container' || e.target.id === 'chat-history') {
                isDraging = true;
                e.preventDefault(); // é˜»æ­¢æ–‡æœ¬é€‰ä¸­ã€æµè§ˆå™¨é»˜è®¤è¡Œä¸ºï¼Œæœç»å¹²æ‰°
                // è®°å½•é¼ æ ‡æŒ‰ä¸‹æ—¶çš„åŸå§‹åæ ‡
                startClientX = e.clientX;
                startClientY = e.clientY;
                chatContainer.style.cursor = 'grabbing';
            }
        });

        // é¼ æ ‡ç§»åŠ¨ï¼šæ ¸å¿ƒæ‹–åŠ¨é€»è¾‘ï¼Œæ— ä»»ä½•å®šä½åˆ‡æ¢ï¼Œ0è®¡ç®—è¯¯å·®
        document.addEventListener('mousemove', function(e) {
            if (!isDraging) return;
            // è®¡ç®—é¼ æ ‡ç§»åŠ¨çš„å·®å€¼ï¼Œä»…åšå¢é‡è®¡ç®—ï¼Œæ— ä»»ä½•å¤æ‚é€»è¾‘
            const dx = e.clientX - startClientX;
            const dy = e.clientY - startClientY;
            // æ ¸å¿ƒï¼šç”¨transformä½ç§»ï¼Œä¸ä¿®æ”¹åŸå®šä½ï¼Œå½»åº•è§„é¿é”šç‚¹å†²çª
            chatContainer.style.transform = `translate(${moveX + dx}px, ${moveY + dy}px)`;
        });

        // é¼ æ ‡æ¾å¼€ï¼šå›ºåŒ–ä½ç§»è·ç¦»ï¼Œä¸‹æ¬¡æ‹–åŠ¨å»¶ç»­å½“å‰ä½ç½®
        document.addEventListener('mouseup', function() {
            if (!isDraging) return;
            isDraging = false;
            chatContainer.style.cursor = 'grab';
            // ä¿å­˜æœ¬æ¬¡æ‹–åŠ¨çš„æœ€ç»ˆä½ç§»é‡ï¼Œè§£å†³æ‹–åŠ¨è®°å¿†é—®é¢˜
            const domMatrix = new DOMMatrix(window.getComputedStyle(chatContainer).transform);
            moveX = domMatrix.e;
            moveY = domMatrix.f;
        });

        // é¼ æ ‡ç¦»å¼€é¡µé¢ï¼Œå¼ºåˆ¶ç»“æŸæ‹–åŠ¨ï¼Œé˜²æ­¢å¡æ­»æ‹–æ‹½çŠ¶æ€
        document.addEventListener('mouseleave', () => {
            isDraging = false;
            chatContainer.style.cursor = 'grab';
        });
        // ===== èŠå¤©çª—å£å¯æ‹–åŠ¨ æ ¸å¿ƒä»£ç  end =====
        const AIBridge = {
            handleResponse(d) {
                hideTyping();
                console.log("ğŸ¤– AI æŒ‡ä»¤:", d);
                addMessage(d.explanation, "ai", d.lean);
                switch (d.operation) {
                    case "vector_add":
                    case "lin_comb":
                        this.drawLinComb(d.inputs);
                        break;
                    case "mat_mul":
                        this.drawMatMul(d.inputs);
                        break;
                    case "eigen":
                        this.drawEigen(d.inputs);
                        break;
                    case "lean_statement":
                    case "lean_intro":
                        break;
                    default:
                        console.warn("æœªçŸ¥çš„æ“ä½œ:", d.operation)
                }
            },
            drawLinComb(inputs) {
                app.reset();
                const vecs = inputs.vectors || [
                        [1, 0],
                        [0, 1]
                    ],
                    p0 = new Point(0, 0);
                app.add(p0);
                const vectors = vecs.map(v => {
                    const p = new Point(v[0], v[1]);
                    app.add(p);
                    const vObj = new Vector(p0, p);
                    app.add(vObj);
                    return vObj
                });
                const comb = new LinearComb(vectors);
                app.add(comb);
                app.select(comb)
            },
            drawMatMul(inputs) {
                app.reset();
                const mVal = inputs.matrix || [
                        [1, 0],
                        [0, 1]
                    ],
                    p0 = new Point(0, 0);
                app.add(p0);
                const pCol1 = new Point(mVal[0][0], mVal[1][0]),
                    pCol2 = new Point(mVal[0][1], mVal[1][1]);
                app.add(pCol1);
                app.add(pCol2);
                const vCol1 = new Vector(p0, pCol1),
                    vCol2 = new Vector(p0, pCol2);
                app.add(vCol1);
                app.add(vCol2);
                const matrix = new Matrix(vCol1, vCol2);
                app.add(matrix);
                const pTest = new Point(1, 1);
                app.add(pTest);
                const vTest = new Vector(p0, pTest);
                app.add(vTest);
                const vTrans = new TransformedVector(matrix, vTest);
                app.add(vTrans);
                app.select(matrix)
            },
            drawEigen(inputs) {
                this.drawMatMul(inputs);
                const mat = app.objects.find(o => o.type === "matrix");
                if (mat) app.add(new EigenSystem(mat))
            }
        };

        function showTyping() {
            hideTyping();
            const history = document.getElementById("chat-history");
            const div = document.createElement("div");
            div.id = "chat-typing";
            div.className = "typing";
            div.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
            history.appendChild(div);
            history.scrollTop = history.scrollHeight
        }

        function hideTyping() {
            const el = document.getElementById("chat-typing");
            if (el) el.remove()
        }
        async function sendChat() {
            const input = document.getElementById("chat-input"),
                msg = input.value.trim();
            if (!msg) return;
            addMessage(msg, "user");
            input.value = "";
            input.disabled = true;
            showTyping();
            try {
                const res = await fetch("http://127.0.0.1:5500/chat", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            message: msg
                        })
                    }),
                    data = await res.json();
                hideTyping();
                if (data.error) {
                    addMessage(`Error: ${data.error}`, "ai")
                } else {
                    AIBridge.handleResponse(data)
                }
            } catch (e) {
                hideTyping();
                addMessage(`Server Error: ${e.message}. Is backend running?`, "ai")
            } finally {
                input.disabled = false;
                input.focus()
            }
        }

        function addMessage(text, role, leanData) {
            hideTyping();
            const history = document.getElementById("chat-history"),
                div = document.createElement("div");
            div.className = `msg-${role}`;
            let html = window.marked ? marked.parse(text) : text;
            if (leanData) {
                html += `<div style="margin-top:8px;border-top:1px solid #475569;padding-top:4px;"><div style="font-weight:bold;color:#fb923c;font-size:11px;">${leanData.statement_cn||"Lean å®šç†"}</div>`;
                if (leanData.lean_code) html += `<pre>${leanData.lean_code}</pre>`;
                if (leanData.hint) html += `<div style="color:#94a3b8;font-style:italic;font-size:11px;margin-top:4px;">ğŸ’¡ ${leanData.hint}</div>`;
                html += "</div>"
            }
            div.innerHTML = html;
            history.appendChild(div);
            history.scrollTop = history.scrollHeight
        }
    </script>
</body>
</html>


